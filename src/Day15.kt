import kotlin.math.absimport kotlin.system.measureTimeMillisfun main() {    fun parseSensorsBeacons(input: List<String>): Map<Vector2D, Vector2D> {        return input.associate { line ->            val split = line.split("=", ",", ":")            Vector2D(split[1].toInt(), split[3].toInt()) to Vector2D(split[5].toInt(), split[7].toInt())        }    }    fun xInDistanceAtY(sensor: Vector2D, distance: Int, y: Int): List<Int> {        val yDistance = abs(sensor.y - y)        if (yDistance > distance) return listOf()        val remainingDistance = distance - yDistance        return IntRange(sensor.x - remainingDistance, sensor.x + remainingDistance).toList()    }    fun rangeAtY(sensor: Vector2D, distance: Int, y: Int): IntRange? {        val yDist = abs(sensor.y - y)        if (yDist > distance) return null        val restDist = distance - yDist        return IntRange(sensor.x - restDist, sensor.x + restDist)    }    fun part1(input: List<String>): Int {        val sensorToBeacons = parseSensorsBeacons(input)        val beaconsCount = sensorToBeacons.values.filter { it.y == 2_000_000 }.toSet().size        val sensorToDistances = sensorToBeacons.mapValues { (s, b) -> s.manhattenDistance(b) }        return sensorToDistances            .mapNotNull { (s, d) -> rangeAtY(s, d, 2_000_000) }            .maxReduce()            .sumOf { it.count() } - beaconsCount    }    fun part2(input: List<String>): Int {        val sensorToDistances = parseSensorsBeacons(input).mapValues { (s, b) -> s.manhattenDistance(b) }        for (y in 0..4_000_000) {            if (y % 1000 == 0) println("y: $y")            val size = sensorToDistances                .mapNotNull { (s, d) -> rangeAtY(s, d, 2_000_000) }                .maxReduce()                .map { it.limit(0, 4_000_000) }                .sumOf { it.count() }            if (size < 4_000_001) {                return y            }        }        return 0    }//    val testinput = readInput("Day15_test")//    println(part1(testinput))    val input = readInput("Day15")    println(part1(input))    println(part2(input))}private fun IntRange.limit(minStart: Int, maxEnd: Int): IntRange {    return maxOf(minStart, start)..minOf(maxEnd, last)}private fun List<IntRange>.maxReduce(): Set<IntRange> {    if (isEmpty()) return emptySet()    val iterator = this.sortedWith(compareBy({ it.first }, { it.last })).listIterator()    var last = iterator.next()    val reduced = mutableSetOf<IntRange>()    while (iterator.hasNext()) {        val next = iterator.next()        last = if (next.first <= last.last) {            IntRange(last.first, maxOf(next.last, last.last))        } else {            reduced.add(last)            next        }    }    reduced.add(last)    return reduced}